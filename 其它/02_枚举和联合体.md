# 1. 枚举（enum）

枚举是一种用户定义的数据类型，用于定义一组命名的整数常量。它让代码更具可读性和可维护性。

## 1.1 简单案例

比如去餐厅点餐：

```cpp
// 定义饮料选项
enum Drink {
    COKE,    // = 0
    SPRITE,  // = 1  
    ORANGE,  // = 2
    BEER     // = 3
};

int main() {
    // 点饮料
    Drink myDrink = COKE;  // 我要点可乐
    
    // 根据饮料做不同的事情
    if (myDrink == COKE) {
        cout << "给你可乐！" << endl;
    }
    else if (myDrink == BEER) {
        cout << "请出示身份证！" << endl;
    }
    
    return 0;
}
```

用枚举比直接用数字 `0, 1, 2, 3` 更清楚，防止你点不存在的饮料（比如数字999），同时代码也更容易看懂。

## 1.2 基本语法和使用

1. 传统枚举（C风格）

```cpp
enum Color {
    RED,        // 默认值为0
    GREEN,      // 默认值为1
    BLUE        // 默认值为2
};

// 传统枚举的使用
Color myColor = RED;
std::cout << "Color value: " << myColor << std::endl; // 输出: 0
```

2. 指定起始值的枚举

```cpp
enum Weekday {
    MONDAY = 1,
    TUESDAY,    // 自动为2
    WEDNESDAY,  // 自动为3
    THURSDAY,   // 自动为4
    FRIDAY      // 自动为5
};
```

3. C++11 强类型枚举（推荐使用）

```cpp
enum class Status {
    SUCCESS,
    FAILURE,
    PENDING
};

// 强类型枚举的使用（需要作用域解析）
Status myStatus = Status::SUCCESS;
// std::cout << myStatus << std::endl; // 错误！强类型枚举不能隐式转换为整数

// 需要显式转换
std::cout << "Status value: " << static_cast<int>(myStatus) << std::endl;
```

实际应用示例：状态机

```cpp
enum class GameState {
	MENU,
	PLAYING,
	PAUSED,
	GAME_OVER
};

int main() {

    GameState current = GameState::MENU;
    
    // 使用switch处理不同状态
    switch (current) {
        case GameState::MENU:
            std::cout << "显示主菜单" << std::endl;
            break;
        case GameState::PLAYING:
            std::cout << "游戏进行中" << std::endl;
            break;
        // ... 其他情况
    }
    
    return 0;
}
```


4. 带指定底层类型的强类型枚举

```cpp
enum class Priority : unsigned char {
    LOW = 1,
    MEDIUM = 2,
    HIGH = 3
};
```


## 1.3 枚举的优势

- **可读性**：`Color::RED` 比数字 `0` 更清晰
- **类型安全**：强类型枚举防止意外的类型转换
- **维护性**：修改枚举值时只需改一处
- **调试友好**：调试器能显示枚举名称而非数字

---

# 2.联合体（union）

联合体是一种特殊的数据结构，所有成员共享同一块内存空间。在任意时刻，联合体只能保存其中一个成员的值。

## 2.1 简单案例

想象你有一个**神奇的盒子**，但它有个特殊规则：
- 这个盒子**只能装一样东西**
- 如果你放苹果进去，之前装的橘子就消失了
- 如果你放书进去，苹果就消失了

```cpp
// 定义一个神奇盒子
union MagicBox {
    int number;      // 可以装整数
    float decimal;   // 可以装小数  
    char text[20];   // 可以装文字
};

int main() {
    MagicBox box;
    
    // 装数字
    box.number = 100;
    cout << "盒子里的数字: " << box.number << endl; // 输出: 100
    
    // 现在装小数（数字就没了！）
    box.decimal = 3.14;
    cout << "盒子里的小数: " << box.decimal << endl; // 输出: 3.14
    // 注意：box.number 现在是乱码，不能用了！
    
    // 现在装文字（小数就没了！）
    strcpy(box.text, "Hello");
    cout << "盒子里的文字: " << box.text << endl; // 输出: Hello
    
    return 0;
}
```


## 2.2 基本语法和使用

1. 基本联合体

```cpp
union Data {
    int i;
    float f;
    char str[20];
};

int main() {
    // 基本联合体示例
    Data data;
    
    data.i = 10;
    std::cout << "data.i: " << data.i << std::endl;
    
    data.f = 220.5;
    std::cout << "data.f: " << data.f << std::endl;
    // 注意：此时data.i的值已经被覆盖，是未定义的！
    
    strcpy(data.str, "Hello");
    std::cout << "data.str: " << data.str << std::endl;
    
    // 联合体大小：等于最大成员的大小
    std::cout << "Size of union Data: " << sizeof(Data) << std::endl;
    std::cout << "Size of int: " << sizeof(int) << std::endl;
    std::cout << "Size of float: " << sizeof(float) << std::endl;
    std::cout << "Size of char[20]: " << sizeof(char[20]) << std::endl;
    
    // 自定义变体类型示例
    Variant v1(42);
    Variant v2(3.14f);
    Variant v3("Hello World");
    
    std::cout << "v1: " << v1.getInt() << std::endl;
    std::cout << "v2: " << v2.getFloat() << std::endl;
    std::cout << "v3: " << v3.getString() << std::endl;
    
    return 0;
}
```

2. 现代C++联合体（带构造函数和析构函数）

```cpp
union ModernData {
    int integer;
    float floating;
    char* string_ptr;
    
    // 构造函数
    ModernData() : integer(0) {}
    
    // 析构函数（需要手动管理资源）
    ~ModernData() {}
};
```

3. 实际应用：实现变体类型（类似std::variant的简化版）

```cpp
class Variant {
private:
    enum class Type { INT, FLOAT, STRING } type;
    union {
        int i;
        float f;
        char* s;
    };
    
public:
    // 构造函数
    Variant(int value) : type(Type::INT), i(value) {}
    Variant(float value) : type(Type::FLOAT), f(value) {}
    Variant(const char* value) : type(Type::STRING) {
        s = new char[strlen(value) + 1];
        strcpy(s, value);
    }
    
    // 析构函数
    ~Variant() {
        if (type == Type::STRING) {
            delete[] s;
        }
    }
    
    // 获取值的方法
    Type getType() const { return type; }
    
    int getInt() const { 
        if (type == Type::INT) return i;
        throw std::runtime_error("Not an integer");
    }
    
    float getFloat() const {
        if (type == Type::FLOAT) return f;
        throw std::runtime_error("Not a float");
    }
    
    const char* getString() const {
        if (type == Type::STRING) return s;
        throw std::runtime_error("Not a string");
    }
};
```

## 2.3 联合体的特点

- **内存共享**：所有成员共享同一内存地址
- **节省内存**：只分配最大成员所需的内存
- **危险性**：必须手动跟踪当前存储的是哪个成员
- **不能有虚函数**：联合体不能包含虚函数
- **构造函数限制**：C++11之前不能有构造函数

