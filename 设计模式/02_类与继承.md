# 1.子类对父类的访问权限

假设有如下的继承链（public 继承）：

```
A  (最顶层基类)
│
├─ B  : public A
   │
   ├─ C : public B
      │
      └─ D : public C
```
只要都是 **public 继承**，整条链保持 **is-a** 关系：D is-a C，C is-a B，B is-a A。

下表是各子类对前面所有类中的访问权限，以下均指**非 friend、非静态**的普通成员，且仅讨论 public 继承。

| 成员在祖先类中的级别       | B 能访问 | C 能访问 | D 能访问 | 外部代码能否通过对象访问 |
| ---------------- | ----- | ----- | ----- | ------------ |
| A 的 public 成员    | ✅     | ✅     | ✅     | ✅            |
| A 的 protected 成员 | ✅     | ✅     | ✅     | ❌            |
| A 的 private 成员   | ❌     | ❌     | ❌     | ❌            |
| B 的 public 成员    | —     | ✅     | ✅     | ✅            |
| B 的 protected 成员 | —     | ✅     | ✅     | ❌            |
| B 的 private 成员   | —     | ❌     | ❌     | ❌            |
| C 的 public 成员    | —     | —     | ✅     | ✅            |
| C 的 protected 成员 | —     | —     | ✅     | ❌            |
| C 的 private 成员   | —     | —     | ❌     | ❌            |

关键点：
1. **private 成员永远只在本类内部可见**，无论隔多少层派生都不可见。  
2. **protected 成员可以一路被后面的派生类使用**，但外部代码（包括这些派生类实例出的对象）不能直接访问。  
3. **public 成员在 public 继承链中保持公开**，外部可通过任何派生类对象调用。

---

# 2.多重继承

## 2.1 简单多重继承

C++ 支持**多重继承**（multiple inheritance），语法是 **逗号分隔**。

```cpp
class C : public A, public B, [public ...] {
    // C 的成员
};
```

- `C` 同时继承了 `A` 和 `B` 的 public / protected 成员。  
- 外部代码可以通过 `C` 对象访问来自 `A` 和 `B` 的 public 接口。  
- 如果 `A` 和 `B` 有同名成员，需要在 `C` 中用 **类名限定** 来消除二义性。

```cpp
// 类名限定
C c;
c.A::foo();   // 调用 A 版本的 foo
c.B::foo();   // 调用 B 版本的 foo
```

## 2.2 菱形继承（避免出现）

**菱形继承（diamond inheritance）**时（例如 `A` 和 `B` 又共同继承自某个基类），需要使用 **虚继承** `virtual` 来避免两份基类子对象；否则会出现“菱形问题”（数据冗余和二义性），对于这部分，简单了解即可，应该在实际项目中尽量避免菱形继承的出现。

菱形继承链：

```
      A
    /   \
   B     C
    \   /
      D
```

代码示例：

```cpp
class A {
public:
    virtual void foo() { /* A 的实现 */ }
};

class B : public A {
public:
    void foo() override { /* B 的重写 */ }
};

class C : public A {
public:
    void foo() override { /* C 的重写 */ }
};

class D : public B, public C {
    // ...
};
```

会出现的问题  
- **数据冗余**：`D` 的对象里会存在 **两份独立的 `A` 子对象**（一份来自 `B`，一份来自 `C`）。  
- **二义性**：这里 D 会同时继承 B::foo() 和 C::foo()，编译器不知道应该选择哪一个（编译器不知道要走 `B` 路径还是 `C` 路径）。 

   ```cpp
   D d;
   // d.foo();      // ❌ 二义性
   // d.A::foo();   // ❌ 编译错误：对成员 'foo' 的请求不明确
   ```

解决方法如下：

1. 方法一：使用虚继承

```cpp
class A {
public:
    virtual void foo() { /* A 的实现 */ }
};

class B : virtual public A {  // 虚继承
public:
    void foo() override { /* B 的重写 */ }
};

class C : virtual public A {  // 虚继承
public:
    void foo() override { /* C 的重写 */ }
};

class D : public B, public C {
public:
    // 现在需要 D 自己重写 foo() 来解决二义性
    void foo() override {
        // 可以选择调用 B::foo()、C::foo() 或提供新的实现
        B::foo();  // 例如选择 B 的版本
    }
};
```


2. 方法二：在 D 中明确指定使用哪个版本

```cpp
class D : public B, public C {
public:
    using B::foo;  // 明确指定使用 B 的 foo
    // 或者
    // using C::foo;  // 明确指定使用 C 的 foo
};
```

3. 方法三：在调用时明确指定

```cpp
D d;
d.B::foo();  // 明确调用 B 的版本
d.C::foo();  // 明确调用 C 的版本
```

>> **注意：** 虚继承会让对象的布局更复杂，构造/析构顺序由最派生类负责；通常只在“公共基类只应有一份”的场景下使用。因此，**<u>对于菱形继承，能不用就不用</u>**，优先选择组合或者接口式多继承，必须用时，要小心设计（通常基类应当是抽象接口，并且使用 `virtual` 继承）。

