# 1.基本概念

对于指针，指针（`T*`）本质上是一个变量，**里面存放的是另一块内存的地址**，那块内存里放着一个（或多个）`T` 类型对象。同样，完全可以把指针当成一个**整型的数据**（比如：`0x7ffd94cd9564`，这是一个整型数据，但表示的是内存块的地址）。

- **两大操作符**
    
    - 取地址：`&obj` 得到 `obj` 的地址（类型是 `T*`）。
        
    - 解引用：`*p` 访问指针 `p` 所指向的对象本身（类型是 `T&`）。

```cpp
int x = 42;
int* p = &x;    // p 里装的是 x 的地址
*p = 7;         // 通过 p 改 x，x 变成 7
```

假设 `x` 的地址是 `0x10a3`，那么 `p` 这个变量装的内容就是 `0x10a3`（即指向的就是一块内存地址），当用 `*p` 时，实际上就是**取 `0x10a3` 这个地址的值**。

---

# 2.指针 vs 引用

- **引用**是已有对象的**别名**，不能为 `null`（语义上），一旦绑定就**不可改指向**。
    
- **指针**可以为空（`nullptr`）、可以指向不同对象、可以做算术（数组场景）。
    
- **指针的引用** = “**指针变量本身**的别名”。

```cpp
void f(int *&rp) {         // rp 是“指向 int 的指针”的引用
    static int y = 99;
    rp = &y;               // 这会修改调用方的指针变量本身
}

int x = 1;
int* p = &x;
f(p);                      // p 现在指向 y 了
```

---

# 3.存储期与所有权

理解“对象活多久”和“谁负责释放”是用好指针的关键。

- **自动存储（栈）**：局部变量，离开作用域自动销毁。
    
- **静态存储**：程序期内一直存在（`static`、全局）。
    
- **动态存储（堆）**：`new` 分配，**你负责**用 `delete`、`delete[]` 释放。

创建一个指针 root，让 root 指向内存中存放 2 这个数字的地址：

```cpp
TreeNode* root = new TreeNode(2); // 在堆上
```

像这样：

```
栈 (stack)         堆 (heap)
----------         -------------
root ────────────▶ [ TreeNode(2) ]
```

删除内存中存放 2 这个数字的地址的数据：

```cpp
delete root;                      // 释放堆内存（root 变量本身还在）
root = nullptr;                   // 防止悬空
```

像这样：

```
栈 (stack)         堆 (heap)
----------         -------------
root ────────────▶ [   已释放   ]
```

> 关键点：`delete root;` **释放的是 root 指向的对象**（在这里，root 指向的就是存放 2 这个数的节点的地址），不是把 `root` 这个变量“删掉”。`root` 仍然存在，但变成悬空指针，所以要把它设为 `nullptr`。

一颗小树的内存示意图😀：

```cpp
// 内存布局示意图（假设地址从0x1000开始）

// TreeNode结构定义（假设）:
struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

// 创建节点后的内存状态:
TreeNode* root = new TreeNode(8);    // 地址: 0x1000
root->left = new TreeNode(4);        // 地址: 0x2000  
root->right = new TreeNode(12);      // 地址: 0x3000

/*
内存布局:

栈内存:
+-----------+----------+
| 变量名    | 值       |
+-----------+----------+
| root      | 0x1000   |
+-----------+----------+

堆内存:
地址 0x1000 (root 指向的地址):
+----------+----------+----------+
| val: 8   | left:0x2000 | right:0x3000 |
+----------+----------+----------+

地址 0x2000 (root->left 指向的地址):
+----------+----------+----------+
| val: 4   | left:nullptr | right:nullptr |
+----------+----------+----------+

地址 0x3000 (root->right 指向的地址):
+----------+----------+----------+
| val: 12  | left:nullptr | right:nullptr |
+----------+----------+----------+
*/

// 树形结构:
//       8
//      / \
//     4   12
```

---

# 4.常见指针的“坑”

- **未初始化指针（野指针）**：`int* p; *p = 1;` —— 未定义行为。
    
- **空指针解引用**：`int* p = nullptr; *p = 1;` —— 未定义行为。
    
- **悬空指针（use-after-free）**：`delete p; *p = 1;` —— 未定义行为。
    
- **双重释放**：同一块内存 `delete` 两次 —— 未定义行为。
    
- **数组释放方式错误**：`new[]` 必须 `delete[]`；单对象 `new` 必须 `delete`。
    
- **多态删除没虚析构**：通过**基类指针**删除派生对象，基类析构必须 `virtual`，否则派生析构不会被调用，资源泄漏。

---

# 5.指针的其它要点

## 5.1 const 与指针组合

- `const int* p`：**指向常量的指针**（不能通过 `p` 改所指对象；p 自己能改指向）
    
- `int* const p`：**常量指针**（p 不能改指向；但能改所指对象）
    
- `const int* const p`：两者都不能改

```cpp
int a=1, b=2;
const int* p = &a;   // *p 只读，p 可改
p = &b;              // OK

int* const q = &a;   // q 不可改指向，*q 可改
*q = 3;              // OK
```


## 5.2 指针与数组

- 数组名在大多数表达式里会**衰变**为指向首元素的指针（`T*`）。
    
- 指针可以做**指针算术**：`p+1` 指向下一个元素（步长按 `sizeof(T)`）。
    
- `sizeof(arr)` 与 `sizeof(p)` 不同：前者是数组大小（字节数），后者是指针大小。

```cpp
int arr[3] = {1,2,3};
int* p = arr;      // 等价于 &arr[0]
*(p+1) = 42;       // 改 arr[1]
```

> 注意：`std::vector` 增长会搬家，**保存它元素的指针/引用会失效**。


## 5.3 函数参数传递的几种方式

- `T* p`：传入一个地址的**拷贝**；你改 `p` 的指向，**调用方看不见**。
    
- `T*& p`：传入“指针本身的引用”；你改 `p` 的指向，**调用方同步改变**（BST 删除用的就是它）。
    
- `T& x`：传入对象别名；不能为 null，不能改引用的绑定对象。


## 5.4 其他指针类型（知道即可）

- **`void*`**：无类型指针，只能存地址，不能直接解引用；需要强转回原类型。
    
- **成员指针**：`int C::* pm;` / `int (C::*pf)(...)`。调用语法特殊：`(obj.*pf)()`、`(ptr->*pm)`。
    
- **指向函数的指针**：`int (*fp)(int);`；现代 C++ 更推荐用 `auto`、`std::function`、lambda。
    
- **类型转换**：
    
    - `static_cast`：编译期安全、常用；
        
    - `reinterpret_cast`：位级别重解释，危险；
        
    - `const_cast`：加/去 const；
        
    - `dynamic_cast`：多态向下转型，需多态基类（有虚函数），失败返回 `nullptr`（指针场景）。
        