# 1.虚函数

**虚函数（Virtual Function）** 是 C++ 中用于实现**多态（Polymorphism）**的一种机制。它是在基类中使用 `virtual` 关键字声明的成员函数。其核心目的是允许在派生类中**重写（Override）** 这个函数，从而根据对象的实际类型（而不是指针或引用的类型）来调用正确的函数版本。

当一个函数被声明为虚函数后，它在所有派生类中默认也是虚函数（即使在派生类前没有显式写上 `virtual`，但写上是一个好习惯，可以提高代码可读性）。

## 1.1 基本语法

```cpp
class Base {
public:
    virtual void show() { // 声明为虚函数
        std::cout << "Base show()" << std::endl;
    }
};

class Derived : public Base {
public:
    void show() override { // 重写虚函数 (使用 override 关键字是 C++11 的好习惯)
        std::cout << "Derived show()" << std::endl;
    }
};
```

## 1.2 虚函数作用

虚函数最大的用途就是实现**“运行时多态”**或**“动态绑定”**。下面通过一个没有虚函数和有虚函数的对比来理解它的巨大作用。

场景 1：没有虚函数（静态绑定）

```cpp
#include <iostream>
using namespace std;

class Base {
public:
    void show() { // 普通函数
        cout << "Base show()" << endl;
    }
};

class Derived : public Base {
public:
    void show() { // 隐藏了基类的 show() 函数
        cout << "Derived show()" << endl;
    }
};

int main() {
    Base base;
    Derived derived;

    base.show();    // 输出: Base show()
    derived.show(); // 输出: Derived show()

	// 调用哪个函数取决于指针的类型，而不是它指向的对象的实际类型
    Base* ptr = &derived; // 基类指针指向派生类对象
    ptr->show();    // 输出: Base show() ！！！问题所在！！！

    return 0;
}
```

**关键问题**：`ptr->show()` 输出的是 `Base show()`。这是因为 `ptr` 的类型是 `Base*`，在编译时，编译器看到 `ptr` 是 `Base*` 类型，就直接绑定了`Base::show()`。这叫做**早期绑定（Early Binding）** 或**静态绑定（Static Binding）**。这不是我们想要的行为，我们希望它根据实际的对象 `Derived` 来调用 `Derived::show()`。

场景 2：使用虚函数（动态绑定）

```cpp
#include <iostream>
using namespace std;

class Base {
public:
    virtual void show() { // 关键：声明为虚函数
        cout << "Base show()" << endl;
    }
};

class Derived : public Base {
public:
    void show() override { // 重写虚函数
        cout << "Derived show()" << endl;
    }
};

int main() {
    Base base;
    Derived derived;

    base.show();    // 输出: Base show()
    derived.show(); // 输出: Derived show()

    Base* ptr = &derived; // 基类指针指向派生类对象
    ptr->show();    // 输出: Derived show() ！！！正确了！！！

    return 0;
}
```

现在，`ptr->show()` 输出了 `Derived show()`！这就是多态的魅力。

**工作原理**：当编译器看到一个虚函数被调用时，它不会在编译时直接进行函数绑定。相反，它会为包含虚函数的类生成一个 **虚函数表（vtable）** 和一个指向该表的 **虚函数表指针（vptr）**。

- **vtable**：一个函数指针数组，存放该类所有虚函数的地址。
- **vptr**：每个对象在创建时，编译器都会悄悄地在其内存布局的开头（通常是）添加一个隐藏的 `vptr` 成员，它指向该类的 `vtable`。

当 `Derived` 对象被创建时，它的 `vptr` 指向 `Derived` 的 `vtable`，而 `Derived` 的 `vtable` 中 `show()` 的地址是 `Derived::show()`。

当执行 `ptr->show()` 时，会发生以下过程：
1. 通过 `ptr` 找到对象的 `vptr`。
2. 通过 `vptr` 找到类的 `vtable`。
3. 在 `vtable` 中找到 `show()` 函数的地址。
4. 调用该地址指向的函数（即 `Derived::show()`）。

这个过程发生在**运行时**，因此被称为**晚期绑定（Late Binding）** 或**动态绑定（Dynamic Binding）**。调用哪个函数完全取决于对象在运行时的实际类型。

## 1.3 虚函数的重要特性与规则

1. **析构函数应为虚函数**
    - 这是虚函数最重要的应用场景之一。如果基类的析构函数不是虚的，那么通过基类指针删除一个派生类对象时，只会调用基类的析构函数，从而导致派生类的部分**内存泄漏**。

2. **纯虚函数与抽象类**
    - 可以将虚函数声明为“纯虚函数”，强制派生类必须重写它。
    - 语法：`virtual ReturnType FunctionName() = 0;`
    - 包含**至少一个纯虚函数**的类称为**抽象类（Abstract Class）**，它不能实例化对象。它的作用是为所有派生类定义一个统一的接口（用于**设计模式**中）。

3. **override 关键字 (C++11)**
    - 显式地表明意图是重写基类的虚函数。
    - 如果加上 `override` 但函数并没有成功重写任何一个基类虚函数（比如函数名拼写错误，或参数列表不同），编译器会报错。这是一个非常有用的安全特性，可以避免意外创建新函数。

4. **final 关键字 (C++11)**
    - 可以用于类（表示**该类不能被继承**）或虚函数（表示该虚函数在派生类中不能再被重写）。

---

# 2.析构函数应为虚函数

**如果基类的析构函数不是虚函数，那么通过基类指针去删除一个派生类对象时，只会调用基类的析构函数，而不会调用派生类的析构函数。这会导致派生类独有的资源（如动态内存、文件句柄等）无法被释放，从而造成资源泄漏（Resource Leak）。**

## 2.1 场景模拟

没有虚析构函数会怎样？下面是一个会发生灾难的代码：

```cpp
#include <iostream>
using namespace std;

class Base {
public:
    Base() { cout << "Base Constructor" << endl; }
    ~Base() { // 注意：这不是虚函数！
        cout << "Base Destructor" << endl;
    }
};

class Derived : public Base {
public:
    Derived() {
        cout << "Derived Constructor" << endl;
        m_data = new int[100]; // 派生类独有：在堆上分配了大量内存
    }
    ~Derived() {
        cout << "Derived Destructor" << endl;
        delete[] m_data; // 派生类独有：负责释放内存
    }
private:
    int* m_data;
};

int main() {
    Base* obj = new Derived(); // 基类指针指向一个派生类对象

    // ... 使用 obj ...

    delete obj; // 危险操作！！！只看指针的静态类型(Base*)

    return 0;
}
```

**运行这段代码，输出结果是：**
```
Base Constructor
Derived Constructor
Base Destructor
```

**发生了什么？**

1. **构造顺序正常**：先调用 `Base` 的构造函数，再调用 `Derived` 的构造函数。`m_data` 成功分配了100个整数的内存。
2. **析构顺序灾难**：当你执行 `delete obj;` 时，编译器看到指针 `obj` 的**静态类型是 `Base*`**。
>> 因为 `Base` 的析构函数**不是虚函数**，所以编译器采用**静态绑定**。它直接调用 `Base::~Base()`，而完全不知道 `Derived::~Derived()` 的存在。结果是，`Derived` 的析构函数**根本没有被调用**！因此，`delete[] m_data;` 这行代码永远不会执行，那100个整数的内存就一直呆在堆区。

**这就是著名的“局部销毁”问题。** 对象的一部分（基类部分）被销毁了，但派生类独有的部分残留在了内存中。

## 2.2 解决方案

现在，我们只做一个小小的改动，将基类的析构函数声明为 `virtual`。

```cpp
#include <iostream>
using namespace std;

class Base {
public:
    Base() { cout << "Base Constructor" << endl; }
    virtual ~Base() { // 关键改动：声明为虚函数
        cout << "Base Destructor" << endl;
    }
};

class Derived : public Base {
public:
    Derived() {
        cout << "Derived Constructor" << endl;
        m_data = new int[100];
    }
    ~Derived() override { // 好的习惯：加上override
        cout << "Derived Destructor" << endl;
        delete[] m_data;
    }
private:
    int* m_data;
};

int main() {
    Base* obj = new Derived();
    delete obj; // 安全操作！

    return 0;
}
```

**运行这段代码，输出结果是：**
```
Base Constructor
Derived Constructor
Derived Destructor
Base Destructor
```

**发生了什么？**

1. 构造顺序不变。
2. 当你执行 `delete obj;` 时，因为 `Base` 的析构函数是**虚函数**，编译器会启动**动态绑定**机制。
>> 编译器会检查 `obj` 指针**实际指向的对象类型**（是 `Derived` 类型）。由于析构函数的调用顺序是从最派生类到基类，所以它会先调用`Derived::~Derived()`，再调用 `Base::~Base()`。然后，`Derived` 的析构函数成功执行，`delete[] m_data;` 释放了内存，防止了泄漏。最后调用基类的析构函数完成收尾工作。

## 2.3 关键点总结

| 特性 | 没有虚析构函数 | 有虚析构函数 |
| :--- | :--- | :--- |
| **绑定方式** | 静态绑定（看指针类型） | 动态绑定（看对象类型） |
| **`delete basePtr`** | 只调用基类析构函数 | 先调用派生类析构函数，再调用基类析构函数 |
| **后果** | **派生类资源泄漏** | **所有资源正确释放** |
| **性能** | 无额外开销 | 有轻微虚函数开销（查 `vtable`） |

**什么时候该用虚析构函数？**
>> 1. **Polymorphic Base Class（多态基类）**：**如果一个类打算被继承，并且会通过基类指针来操作派生类对象（即有多态的使用场景），那么它的析构函数必须是虚函数。** 这是一个非常重要的C++编程准则。
>> 2. **STL 容器**：标准库中的容器（如 `std::vector`, `std::string` 等）的析构函数不是虚的，因为它们**不设计为被继承**。如果你继承它们并通过基类指针删除，同样会导致问题。所以，不要继承标准库容器。

**什么时候可以不用？**
>> 1. 类不被设计为基类（使用 `final` 关键字或通过设计表明）。
>> 2. 类虽然是基类，但**绝对不会**通过基类指针来删除派生类对象（这种约定非常脆弱，不推荐）。

**只要你在一个类里声明了至少一个虚函数（说明你希望这个类有多态特性），你就应该立即把它的析构函数也声明为虚的。**这是一个很好的编程习惯。

---

# 3.final 关键字

`final` 的两种用法如下：

## 3.1 用于类：禁止继承

当一个类被声明为 `final` 后，任何尝试继承（派生）自这个类的行为都会导致编译错误。

**语法：**
```cpp
class ClassName final { // 在类名后使用 final
    // ... 类成员 ...
};
```

**为什么这么用？**
- **设计意图**：明确表示这个类不是为继承而设计的。类的设计者希望禁止任何人创建它的子类。
- **安全性**：防止因继承而可能带来的潜在错误或未定义行为。
- **优化**：编译器知道这个类不会有任何派生类，有时可以进行更激进的优化。
- **终结功能**：例如，标准库中的 `std::mutex` 之类的类通常是 `final` 的，因为让它们被继承可能会导致资源管理上的灾难。

**示例：**
```cpp
class Base final { // Base 被标记为 final
public:
    void func() {}
};

// 尝试继承 final 类会导致编译错误
class Derived : public Base { // 错误：cannot derive from 'final' base 'Base' in derived type 'Derived'
public:
};
```

## 3.2 用于虚函数：禁止重写

当一个虚函数（在基类或中间派生类中）被声明为 `final` 后，任何在更派生的类中尝试重写（Override）这个函数的行为都会导致编译错误。

**语法：**
```cpp
virtual ReturnType FunctionName(Args) final; // 在函数声明后使用 final
```

**为什么这么用？**
- **设计稳固性**：函数的设计者认为这个函数的实现已经是“最终版本”或“最优版本”，不希望后续的派生类改变其行为，以保证核心逻辑的稳定性和正确性。
- **性能**：编译器知道这个函数在更深层的继承中不会被改变，可能有机会进行去虚拟化（devirtualization）优化，直接调用该函数，省去查虚表的开销。
- **防止错误**：避免在复杂的继承体系中，派生类意外地重写了不该重写的函数。

**示例：**
```cpp
class Base {
public:
    virtual void doSomething() {
        std::cout << "Base implementation" << std::endl;
    }
};

class Derived : public Base {
public:
    // 重写了 doSomething，并将其标记为 final
    void doSomething() override final { // 注意：override 和 final 的顺序
        std::cout << "Derived's final implementation" << std::endl;
    }
};

class FurtherDerived : public Derived {
public:
    // 错误：尝试重写 final 函数
    void doSomething() override { // 错误：virtual function 'virtual void FurtherDerived::doSomething()' overriding final function
        std::cout << "Trying to change it" << std::endl;
    }
};

int main() {
    FurtherDerived obj;
    return 0;
}
```

## 3.3 关键点与总结

1. **明确性**：`final` 使你的代码设计意图更加清晰。看到 `final`，其他程序员就知道“这个类/函数不能再被扩展或修改了”。
2. **编译时检查**：`final` 是一个编译期特性。任何违反 `final` 规则的代码都会在编译时被捕获并报错，不会等到运行时才出问题。
3. **`override` 和 `final` 可以组合使用**：它们的顺序通常是 `override final`（虽然 `final override` 也可以，但 `override final` 更符合逻辑：先表明是重写，再表明是最终版本）。

简单来说，**`final` 就像给你的类或函数贴上一个“封条”**，告诉编译器和其他程序员：“到此为止，不能再往下继承或修改了”。这是一种强大的、表达设计约束的工具。