# 1.使用规则

1. 模板声明语法  
   • `template <class T>` 与 `template <typename T>` **功能等价**，后者语义更直观。  
   • 模板模板参数必须用 `template <template<class> class C>`（C++20 前不能用 `typename`）。

| 语法                      | 说明                                              |
| ----------------------- | ----------------------------------------------- |
| `template <class T>`    | `class` 在这里并不特指“类”，而是泛指“任何类型”（包括基本类型、结构体、联合体等）。 |
| `template <typename T>` | 更明确地表示“T 是一个类型”，避免误解为“只能是 class 类型”。            |


比如：
```cpp
template <template <class> class Container>  // ✅ 必须用 class
struct MyStruct {};

template <template <typename> typename Container>  // ❌ 错误，C++20 前不允许
struct MyStruct {};
```


2. 模板定义必须对编译器可见  
   • 模板**不是**普通函数；只有当编译器在**当前翻译单元**看到完整定义时，才能实例化。  
   • **不能把模板实现放到单独的 `.cpp` 里再链接**，否则会报 “undefined reference”。

---

# 2.使用方法

## 2.1 声明与实现一起（推荐）

示例：

- 函数模板：
```cpp
template <typename T>
T max(T a, T b) {
    return a > b ? a : b;
}

// 使用
int m = max<int>(3, 5); // 显式指定类型
double d = max(3.2, 5.1); // 隐式推导类型
```

- 类模板
```cpp
template <typename T>
class Stack {
private:
    std::vector<T> elements;
public:
    void push(const T& element);
    T pop();
};

// 使用
Stack<int> intStack;
Stack<std::string> stringStack;
```

上面两种方式都是把**模板声明**和**模板实现**放在同一个文件中。但有时候在编写类时，想在头文件（`.hpp`）中进行成员函数的声明，在源文件（`.cpp`）中进行成员函数的实现，就只能用下面的方式。

## 2.2 声明与实现分离

### 2.2.1 方式一：使用显式实例化

1. 在头文件中声明：
```cpp
// stack.h
template <typename T>
class Stack {
private:
    std::vector<T> elements;
public:
    void push(const T& element);
    T pop();
};

// 在头文件末尾显式实例化需要的类型，显式实例化声明（告诉编译器不要在此处实例化）
extern template class Stack<int>;
extern template class Stack<double>;
```

2. 在实现文件中定义：
```cpp
// stack.cpp
#include "stack.h"

template <typename T>
void Stack<T>::push(const T& element) {
    elements.push_back(element);
}

template <typename T>
T Stack<T>::pop() {
    if (elements.empty()) {
        throw std::out_of_range("Stack<>::pop(): empty stack");
    }
    T element = elements.back();
    elements.pop_back();
    return element;
}

// 显式实例化定义（实际实例化位置）
template class Stack<int>;
template class Stack<double>;
```

这是C++11引入的特性：头文件中的 `extern template` 是**显式实例化声明**，告诉编译器"不要在此编译单元实例化这些模板"。cpp 文件中的普通 `template class` 是**显式实例化定义**，确保模板在某个编译单元被实例化。

### 2.2.2 方式二：使用 `.tpp` 文件

具体做法就是**把模板实现单独放到一个 `.tpp` 文件里，然后在 `.hpp` 末尾 `#include "xxx.tpp"`。** 这种情况建议把 `.tpp` 文件放到与其对应的 `.hpp` 文件的同级目录下，如下目录所示：

```
include
├── stack.hpp
└── stack.tpp
```

归根结底，模板不是普通的函数/类——**只有在编译期被用到时才会实例化**。如果把模板实现放到 `.cpp` 里，别的翻译单元（translation unit）只看到声明而看不到实现，链接时就会报 “undefined reference” 错误。因此模板的完整实现必须**对编译器可见**，通常的做法就是把实现放在头文件里。但如果全部堆在一个 `.hpp` 里，文件会特别大，可读性差。

**`.tpp` 说明：**

- `.tpp` 全称是 `Template Partial Programming` 或 `Template imPlementation Partial`，也可以命名为 `.impl`, `.icc`, `.tcc`，但 `.tpp` 是社区里约定俗成的“模板实现文件”后缀。
    
- 它**不会被**单独编译（不会被加到 `add_executable / add_library` 里）。
    
- 它只是被 `#include "graphAdjMat.tpp"` **原封不动地展开**到头文件末尾，相当于把实现“粘贴”进 `.hpp`，但**视觉上分离**了声明和实现。

### 2.2.3 两种方式的对比

| 方式 | 优点 | 缺点 |
|------|------|------|
| **显式实例化** | 编译分离清晰；<br/>编译速度快；<br/>减少代码膨胀 | 必须预先知道所有类型；<br/>不支持新类型；<br/>配置复杂 |
| **`.tpp` 包含** | 支持任意类型；<br/>配置简单；<br/>更灵活 | 编译速度慢；<br/>可能代码膨胀 |

---

# 3.模板显式实例化的时机

当抽象基类也是模板时，可以不用为抽象基类显示实例化，因为抽象基类中只包含纯虚函数声明，不会被直接实例化，只是作为接口使用，而且编译器也不需要为抽象基类生成具体代码。

比如下面这个例子：

```cpp
// IGraph.hpp
#pragma once
#include <vector>

template <typename VertexType>
struct Edge {
	VertexType v1;
	VertexType v2;
	int weight = 1;
};

template <typename VertexType>
class IGraph {
public:
	virtual ~IGraph() = default;
  // ... 纯虚函数声明 ...
};
```

继承层次图：
```
IGraph<T>           ← 抽象基类（无需实例化）
    ↓
GraphAdjMat<T>      ← 基础实现（显式实例化）
    ↓
GraphAdjMatD<T>     ← 有向图扩展（显式实例化）
```

完整示例如下：
```cpp
// IGraph.hpp - 无需实例化
template <typename T> class IGraph { /*...*/ };
```

```cpp
// GraphAdjMat.hpp - 显式实例化
template <typename T> class GraphAdjMat : public IGraph<T> { /*...*/ };
extern template class GraphAdjMat<int>;
extern template class GraphAdjMat<char>;
```

```cpp
// GraphAdjMatD.hpp - 显式实例化
template <typename T> class GraphAdjMatD : public GraphAdjMat<T> { /*...*/ };
extern template class GraphAdjMatD<int>;
extern template class GraphAdjMatD<char>;
```

---

# 4.继承模板访问权限

在C++中，模板类的继承有一些特殊规则，父类的成员（成员变量和成员函数）不会自动在子类中可见，除非显式地通过this->或使用using声明。

1. 普通继承中的情况

在**非模板类**的继承中，子类一般可以直接访问基类的 `protected` 和 `public` 成员。例如：

```cpp
class Base {
protected:
    int x = 42;

public:
    void hello() {
        std::cout << "Hello from Base\n";
    }
};

class Derived : Base {
public:
    void print() {
        std::cout << x << "\n";  // ✅ 直接用，没问题
    }

    void call() {
        hello();  // ✅ 直接可见
    }
};
```

这里 `x` 和 `hello()` 对于子类 `Derived` 是直接可见的。

2. 模板类继承的特殊情况

当基类是**模板类**时，编译器在实例化模板前**无法确定基类里到底有什么名字**。因此，像 `x` 和 `hello()` 这样的名字，在子类作用域中会被认为是“依赖基类的名字（dependent name）”。C++ 规定：编译器不会自动假设这些名字存在，除非你显式地告诉它“去基类里找”。

例子：

```cpp
template <typename T>
class Base {
protected:
    int x = 42;

public:
    void hello() {
        std::cout << "Hello from Base\n";
    }
};

template <typename T>
class Derived : Base {
public:
    void print() {
        std::cout << x << "\n";  // ❌ 错误：编译器不知道 x 从哪来
    }

    void call() {
        hello();  // ❌ 错误：编译器不知道 hello 从哪来
    }
};
```

编译会报错，提示 `x` 和 `hello()` 不可见。

3. 解决方法（有两种常见方法）：

- 方式一：用 `this->`，告诉编译器“`x` 是从基类继承来的成员”。

```cpp
template <typename T>
class Derived : Base {
public:
    void print() {
        std::cout << this->x << "\n";  // ✅ 正确
    }

    void call() {
        this->hello();  // ✅ 正确
    }
};
```

- 方式二：用 `using` 声明，在子类作用域里显式引入基类的成员。

```cpp
template <typename T>
class Derived : Base {
public:
    using Base<T>::x;  // ✅ 引入基类的 x
    void print() {
        std::cout << x << "\n";  // ✅ 正确
    }

    using Base<T>::hello;  // ✅ 引入基类成员函数
    void call() {
        hello();  // ✅ 正确
    }
};
```
